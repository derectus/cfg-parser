# CFG Parser


## Definition
A context-free grammar (CFG) is a set of recursive rewriting rules (or productions) used to generate
patterns of strings.
A CFG consists of the following components:
- a set of terminal symbols, which are the characters of the alphabet that appear in the strings generated by the grammar.
- a set of nonterminal symbols, which are placeholders for patterns of terminal symbols that can be generated by the nonterminal symbols.
- a set of productions, which are rules for replacing (or rewriting) nonterminal symbols (on the
left side of the production) in a string with other nonterminal or terminal symbols (on the right side of the production).
- a start symbol, which is a special nonterminal symbol that appears in the initial string generated by the grammar.
## Algorithm
1. Remove all nonterminal from the right hand side of all productions except the unit productions.
2. Replace any rule that has three or more nonterminals with the equivalent rules of size two.
3. Replace every rule S with S0. Add a new rule S0->S
4. Remove all epsilon transitions by iterating their equivalent form. For each production that includes a terminal that is equal to epsilon, add another rule equal to the initial rule excluding the terminal that is equal to epsilon.
5. Remove all the unit rules of the form A ? B

## Pseudo code

    let the input be a string S consisting of n characters: a1 ... an.
    let the grammar contain r nonterminal symbols R1 ... Rr.
    This grammar contains the subset Rs which is the set of start symbols
    let P[n,n,r] be an array of booleans. Initialize all elements of P to false.
    for each i = 1 to n
    	for each unit production Rj -> ai
    		set P[i,1,j] = true
    for each i = 2 to n -- Length of span
    	for each j = 1 to n-i+1 -- Start of span
    		for each k = 1 to i-1 -- Partition of span
    			for each production RA -> RB RC
    				if P[j,k,B] and P[j+k,i-k,C] then set P[j,i,A] = true
    if any of P[1,n,x] is true (x is iterated over the set s, where s are all the indices for Rs) then
    	S is member of language
    else
    	S is not member of language

## Example

    S -> aS | bB | #
    B -> aB | bS | bC
    C -> aC | #
    
    S -> X S | Y B | a
    B -> X B | Y S | Y C | b
    C -> X C | a
    X -> a
    Y -> b

### Parsing Tree for input : ( a * a ) + a

![Parsing Tree for input : ( a * a ) + a](/images/parsing-tree.png)
